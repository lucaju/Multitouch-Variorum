package view.util.scroll {		//imports		import com.greensock.TweenLite;		import flash.display.Sprite;	import flash.events.Event;	import flash.events.TransformGestureEvent;	import flash.geom.Point;
		public class Scroll extends Sprite{				public const VERTICAL:String = "vertical";		public const HORIZONTAL:String = "horizontal";				//properties		private var _target:Sprite;		private var _mask:Sprite;		private var _hMax:Number = 0;		private var _wMax:Number = 0;		private var _ratePage:Number;		private var _prev_mouse_pos:Point = new Point(0,0);		private var _speed:Point = new Point(0,0);		private var _direction:String = VERTICAL;		private var _offset:Number = 0;				private var friction:Number = 0.98;				private var roll:Roll;		private var track:Track;				public function Scroll() {						// track			track = new Track();			addChild(track);									// Roll			roll = new Roll();			addChild(roll);						//rotate			if (direction == this.HORIZONTAL) {				track.rotation = 90;				track.rotation = 90;			}						this.addEventListener(Event.ADDED_TO_STAGE, addedToStageHandler);					}				//---------  getters ---------  		public function get direction():String {			return _direction;		}				//---------  setters  ---------  		public function set direction(value:String):void {			_direction = value;		}				public function set target(value:Sprite):void {			_target = value;			if (direction == this.VERTICAL) {				if (_hMax != 0) {ratePage()}			} else {				if (_wMax != 0) {ratePage()}			}		}				public function set maskContainer(value:Sprite):void {			_mask = value;			_hMax = _mask.height;			_wMax = _mask.width;			if (_target != null) {ratePage()}		}				private function ratePage():void {						if (direction == this.VERTICAL)  {				_ratePage = _target.height / _mask.height;			} else {				_ratePage = _target.width / _mask.width;			}			scrollSize();		}				public function getRatePage():Number {			return _ratePage;		}				private function scrollSize():void {			//if (_ratePage < 10) {				roll.height = _hMax / _ratePage;				track.height = _hMax;			//}		}				public function get offset():Number {			return _offset;		}				public function set offset(value:Number):void {			_offset = value;		}				private function addedToStageHandler(e:Event):void{						this.parent.addEventListener(TransformGestureEvent.GESTURE_PAN, _handlePan);					}				private function _handlePan(e:TransformGestureEvent):void {						if (direction == this.VERTICAL)  {				_target.y -= 2 * (e.offsetY);			} else if (direction == this.HORIZONTAL) {				_target.x -= 2 * (e.offsetX);			}									switch (e.phase) {								case "update":					_speed.x = -e.offsetX;					_speed.y = -e.offsetY;					break;								case "end":					_target.addEventListener(Event.ENTER_FRAME, throwobject);					break;			}								}				private function throwobject(e:Event):void {						//drirection			switch (direction) {								case this.VERTICAL:										//test boundaries					if (_target.y > 0 + offset) {						TweenLite.to(_target, .3, {y:0 + offset});						_speed.y = 0;					} else if (_target.y < -_target.height + _hMax) {						TweenLite.to(_target, .3, {y:-_target.height + _hMax});						_speed.y = 0;					} else {												//move						_target.y += _speed.y;												//apply friction						_speed.y *= friction;												//limit inertia						if (_speed.y > -.5 && _speed.y < .5) {							_speed.y = 0;						}					}					break;								case this.HORIZONTAL:										//test boundaries					if (_target.x > 0 + offset) {						TweenLite.to(_target, .3, {x:0 + offset});						_speed.x = 0;					} else if (_target.x < -_target.width + _wMax) {						TweenLite.to(_target, .3, {x:-_target.width + _wMax});						_speed.x = 0;					} else {												//move						_target.x += _speed.x;												//apply friction						_speed.x *= friction;												//limit inertia												if (_speed.x > -.5 && _speed.x < .5) {							_speed.x = 0;						}					}					break;			}						//end inertia			if (_speed.x == 0 && _speed.y == 0) {				_target.removeEventListener(Event.ENTER_FRAME, throwobject);			}		}			}	}